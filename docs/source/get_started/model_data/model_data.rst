=======================================
Modeling Data with MOTECH Data Services
=======================================

.. contents:: Table of Contents
   :depth: 3

############
Introduction
############

Motech Data Services(MDS) is the data layer for the Motech Platform. MDS allows defining the data model both through code
(using annotations or the exposed API) and the Schema Editor UI. MDS is capable of generic services which exuting
operations on the defined model. It also is capable of exposing a fully functional REST API for the defined data
model on the fly. Entities defined through means of code can always be extended or get their settings modified
through the MDS Schema Editor or its underlying API.

MDS uses `Datanucleus <http://www.datanucleus.org/>`_ underneath for persistence in a relational data store. Currently
MDS officially supports two RDBMS engines `MySQL <http://www.mysql.com/>`_ and `PostgreSQL <http://www.postgresql.org/>`_.
`Javassist <http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/>`_ is used for code generation and OSGi mechanics such
as bytecode weaving are used for replacing the code at runtime.

MDS generated entities bundle
#############################

All classes generated by MDS live in the mds-entities OSGi bundle, which gets generated at runtime and installed in the
directory ~/.motech/bundles. The bundle is always regenerated when changes are made to the MDS schema.
This generated bundle can also be downloaded using the following url TODO


############
MDS Entities
############


#. :doc:`Using code annotations in a custom module <mds_with_code>`

MDS defines an Entity concept. An MDS entity maps directly to a `POJO <http://wikipedia.org/wiki/Plain_Old_Java_Object>`_ class
and table in relational database. Entities consist of fields which are directly mapped to the object fields and columns
in the table. MDS provides a preset of supported types described TODO.

.. TODO make sure task channel gets done before this doc

MDS integrates itself with the :doc:`Tasks module </modules/tasks>`, so a user can create a working application with a minimal number of code.
Entities generate task data providers which allow access to the data within MDS. Entities can also be configured to publish
Motech events(TODO: link event if we have event docs) which are fired after CRUD operations are completed in MDS.
These CRUD events, are exposed as task triggers in a dynamically generated task channel. CRUD actions are also exposed
as actions within the task module, allowing users to create database manipulating logic through the tasks module.

We can group entities into three categories:

EUDE_ - End User Defined Entities. The entities created using the UI by the end user. These classes do not exist at compile
time, but only after they are generated by MDS. Adding the `bundle generated by <TODO link to section>`_ MDS to the classpath will allow compile
time access however. EUDE entities can also be defined using the MDS API through the EntityService. Users can view and create
instances of the entities through the MDS Data browser TODO: link section.

DDE_ - Developer Defined Entities. Developers can use annotations to mark their `POJO <http://wikipedia.org/wiki/Plain_Old_Java_Object>`_ classes
as MDS Entities. These will be treated in the same way as EUDE entities, instances of the DDEs will also be acessible through
the data browser. Users can still view the schema for these entities through the Schema Editor, add fields and modify
settings(although they can't remove fields declared in the entity class).

MEDE_ - MDS Enhanced Developer Defined Entity. These are DDEs that were enhanced with additional fields added either
through the UI or the Entity API. This are the same as DDE, but with additional fields added at runtime. Those fields
can be accessed at compile time using `Java Reflection API <https://docs.oracle.com/javase/tutorial/reflect/>`_.

###########
MDS Lookups
###########

Lookups allow easily defining and executing queries on MDS entities. A lookup allows querying for a single or multiple
fields. A lookup field is always corresponding to a single field in the entity. Lookups at this moment can only use
AND logic for doing a query for multiple fields. For OR(or move complex) logic JDO queries have to be used TODO: link section.
Lookup also allow comparing fields against provided parameters using a custom operator or using a range or set of values
- defining such is not supported through the UI at the moment though.

.. _EUDE:

################################
EUDE - End User Defined Entities
################################

These entities are created by end users, either through the UI or using the API. No programming knowledge is required
in order to define an EUDE. Although these entities are not known at compile time, unless the jar generated by MDS is added
to the classpath, programmatic access to these entities is still possible using
`Java Reflection API <https://docs.oracle.com/javase/tutorial/reflect/>`_ and some handy helper classes exposed by MDS.

.. note::

    All EUDE share the same java package: **org.motechproject.mds.entity**

Creating EUDE through UI
########################

.. TODO: Note: I have these screenshots ready

The easiest way to create EUDE entities is to use the Motech UI. First select **Data Services** from the left navigation
menu(**Modules** menu), then navigate to the **Schema Editor** tab. You will see a dropdown allowing to select an existing entity for
modification or deletion. Next to the dropdown menu you will see a New Entity button.

    .. image:: img/schema_editor.png
            :scale: 100 %
            :alt: MDS Schema Editor - Adding new Entity
            :align: center

After that the user is asked for the name of the entity. This can be anything that is a legal name of a class in Java.

.. TODO: screenshot

The view for managing entity fields is displayed to the user. Users can add a field by selecting its type, choosing a name
and a display name. 'display name' represents what will be visualised to the users in the MDS Data browser, task editor etc.
'name' represents the actual name of the field that will be used for class and table creation. After this data is entered,
hitting the green plus sign will add the field, the user is then presented with options to modify the field settings

.. TODO: screenshot
.. TODO: screenshot
.. TODO: screenshot
.. TODO: screenshot

The **Basic** sections allows to change the previously entered name and display name, it also allows marking the field
as required, meaning that users will be prevented from creating an instance without any value in this field. A default
value for the field can also be entered, as well as a tooltip that will be shown to users creating instances of the entity.

The **Metadata** section allows adding metadata to the field. This used internally by MDS for features such as relationships.
End users should not worry about this section, but advanced can add any values they wish for their own processing needs.
Metadata is retrieved with the field schema using the Entity API. An example of using metadata could be a scenario when
we are writing a third party export tool, that takes the MDS Schema and imports it into a 3rd party system. The field
metadata can be used by that tool in order to recognize some fields as requiring special processing logic.

The **Validation** section allows setting specific validation rules for the field. Users will then be constrained by these
validations when creating instances of the entity. Validations are type specific.

The **Settings** tab allows users to set type specific settings of the field. An example setting is the 'Max text length'
of a String field, which indicates the maximum length of the string at the database level.

Existing fields can be deleted using the trash bin icon next to their type.

.. TODO screenshot

When the user is done modifying the entity, clicking **Save changes** will save the changes to schema and regenerate
MDS entities. Clicking **Abandon Changes** will abandon all changes made by the user since the last save.

.. TODO screenshot

Defining a Lookup through the UI
################################

Creating EUDE through the Entity API
####################################

.. TODO javadoc link to the the entity service
Creation of entities can be also done using the EntityService. This an OSGi service exposed by MDS
which allows creation and modification of MDS entities, exposing everything what the UI does.
In order to use the service it has to be retrieved from the OSGi context, either directly using the OSGi API
to retrieve it from the BundleContext, or a blueprint reference can be used to inject a proxy for that service directly
as a Spring bean.

Example of retrieving the service manually:

.. code-block:: java

    import org.motechproject.mds.service.EntityService;
    import org.osgi.framework.*;

    ...

    public EntityService getEntityService() {
        // note that if using Spring, the BundleContext can be injected as any other bean
        // which allows skipping this step
        BundleContext bundleContext = FrameworkUtil.getBundle(EntityService.class).getBundleContext();
        // get the service reference from the bundle context
        ServiceReference<EntityService> ref = bundleContext.getServiceReference(EntityService.class);
        // return the service for the reference, or null if there are no references
        // the service should always be available, so a null reference definitely indicates some sort error
        return ref == null ? null : bundleContext.getService(ref);
    }

and using blueprint:

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:osgi="http://www.eclipse.org/gemini/blueprint/schema/blueprint"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.eclipse.org/gemini/blueprint/schema/blueprint
            http://www.eclipse.org/gemini/blueprint/schema/blueprint/gemini-blueprint.xsd">

        <osgi:reference id="entityService" interface="org.motechproject.mds.service.EntityService"/>

    </beans>

.. TODO javadoc link

After getting hold of the service the entity can be created using the createEntity method:

.. code-block:: java

        EntityService entityService = getEntityService();


        EntityDto entity = new EntityDto("Patient");

        // the EntityDto instance returned will have the id value set
        entity = entityService.createEntity(entity);

If we want to edit an existing entity, we can retrieve it using the EntityService:

.. code-block:: java

        // We can use the org.motechproject.mds.util.ClassName utility in order
        // to get the EUDE class name given just the name
        String className = ClassName.getEntityName("Patient");

        // className is org.motechproject.mds.entity.Patient

        EntityDto entity = entityService.getEntityByClassName(className);


When we have the EntityDto instance, fields can get added to the entity using the service and EntityDto returned:

.. TODO, update APIs

.. code-block:: java

        // a simple integer field
        FieldDto simpleField = new FieldDto("simpleInt", "Simple integer", TypeDto.INTEGER);

        // a required name field
        FieldDto nameField = new FieldDto("name", "Patient Name", TypeDto.STRING, true);

        // an optional date of birth field, with a tooltip
        FieldDto dobField = new FieldDto("dob", "Date of Birth", TypeDto.DATETIME, false, null,
                "Patients date of birth, leave blank if unknown");

        // a required Social ID field, defaulting to 0
        FieldDto socialIdField = new FieldDto("socialId", "Social ID", TypeDto.LONG, true, 0L);

        // add the fields to the entity created earlier
        entityService.addFields(entity, simpleField, nameField, dobField, socialIdField);


.. TODO links...

After we are done with modifications to the entity schema, we must trigger regeneration in order for the
classes to get updated and available in OSGi. For this we need to use the JarGeneratorService, which we can
retrieve the same way that we can retrieve the EntityService. Once we have an instance of the service, all we
need to do is call the regenerateMdsDataBundle method:

.. code-block:: java

    JarGeneratorService jarGeneratorService = getJarGeneratorService();

    jarGeneratorService.regenerateMdsDataBundle();


After the schema gets regenerated and all bundles using MDS get refreshed, the EUDE class should be available for use.

Creating Lookups through the API
################################

Programmatic access to EUDE entities
####################################

Adding the generated jar to the classpath
#########################################
.. TODO: Make sure this works and describe how to do it
.. TODO: If it doesn't work we should drop this section for now & create a bug
.. TODO: Show how to do it with mvn and IntelliJ

.. _DDE:

################################
DDE - Developer Defined Entities
################################

Defining entities - the @Entity annotation
##########################################

DDE entity fields - @Field and @Ignore annotations
##################################################

DDE inheritance
###############

DDE relationships
#################

DDE service interfaces
######################

Programmatic usage of DDE entities
##################################

.. _MEDE:

##############################################
MEDE - MDS Enhanced Developer Defined Entities
##############################################

Extending DDEs through the UI
#############################


Extending DDEs through code
###########################



#####################
Supported field types
#####################


#############################
History tracking for entities
#############################


Controlling whether to record history
#####################################


Retrieving history using code
#############################


#############
MDS Trash Bin
#############


Using Trash using code
######################


####################
The MDS data browser
####################


######################
Data browsing settings
######################


Changing the settings through the UI
####################################

Changing the settings through annotations
#########################################

############
The REST API
############


REST endpoints
##############

REST fields exposed
###################

Changing REST settings through the UI
#####################################

Changing REST settings through annotations
##########################################


##################
Entity validations
##################

Configuring validations through the UI
######################################

Configuring validations using annotations
#########################################

##################
MDS Lookup Service
##################


########################
Executing custom queries
########################

########
Security
########

#################
Tasks integration
#################

#######
Javadoc
#######

:doc:`/org/motechproject/mds/service/package-index`

:doc:`/org/motechproject/mds/annotations/package-index`

:doc:`/org/motechproject/mds/builder/package-index`

:doc:`/org/motechproject/mds/config/package-index`

:doc:`/org/motechproject/mds/domain/package-index`

:doc:`/org/motechproject/mds/dto/package-index`

:doc:`/org/motechproject/mds/enhancer/package-index`

:doc:`/org/motechproject/mds/ex/package-index`

:doc:`/org/motechproject/mds/filter/package-index`

:doc:`/org/motechproject/mds/jdo/package-index`

:doc:`/org/motechproject/mds/repository/package-index`

:doc:`/org/motechproject/mds/util/package-index`

:doc:`/org/motechproject/mds/web/package-index`
