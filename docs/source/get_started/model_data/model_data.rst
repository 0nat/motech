=======================================
Modeling Data with MOTECH Data Services
=======================================

.. contents:: Table of Contents
   :depth: 3

############
Introduction
############

Motech Data Services(MDS) is the data layer for the Motech Platform. MDS allows defining the data model both through code
(using annotations or the exposed API) and the Schema Editor UI. MDS is capable of generic services which exuting
operations on the defined model. It also is capable of exposing a fully functional REST API for the defined data
model on the fly. Entities defined through means of code can always be extended or get their settings modified
through the MDS Schema Editor or its underlying API.

MDS uses `Datanucleus <http://www.datanucleus.org/>`_ underneath for persistence in a relational data store. Currently
MDS officially supports two RDBMS engines `MySQL <http://www.mysql.com/>`_ and `PostgreSQL <http://www.postgresql.org/>`_.
`Javassist <http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/>`_ is used for code generation and OSGi mechanics such
as bytecode weaving are used for replacing the code at runtime.

MDS generated entities bundle
#############################

All classes generated by MDS live in the mds-entities OSGi bundle, which gets generated at runtime and installed in the
directory ~/.motech/bundles. The bundle is always regenerated when changes are made to the MDS schema.
This generated bundle can also be downloaded using the following url TODO


############
MDS Entities
############


#. :doc:`Using code annotations in a custom module <mds_with_code>`

MDS defines an Entity concept. An MDS entity maps directly to a `POJO <http://wikipedia.org/wiki/Plain_Old_Java_Object>`_ class
and table in relational database. Entities consist of fields which are directly mapped to the object fields and columns
in the table. MDS provides a preset of supported types described TODO.

.. TODO make sure task channel gets done before this doc

MDS integrates itself with the :doc:`Tasks module </modules/tasks>`, so a user can create a working application with a minimal number of code.
Entities generate task data providers which allow access to the data within MDS. Entities can also be configured to publish
Motech events(TODO: link event if we have event docs) which are fired after CRUD operations are completed in MDS.
These CRUD events, are exposed as task triggers in a dynamically generated task channel. CRUD actions are also exposed
as actions within the task module, allowing users to create database manipulating logic through the tasks module.

We can group entities into three categories:

EUDE_ - End User Defined Entities. The entities created using the UI by the end user. These classes do not exist at compile
time, but only after they are generated by MDS. Adding the `bundle generated by <TODO link to section>`_ MDS to the classpath will allow compile
time access however. EUDE entities can also be defined using the MDS API through the EntityService. Users can view and create
instances of the entities through the MDS Data browser TODO: link section.

DDE_ - Developer Defined Entities. Developers can use annotations to mark their `POJO <http://wikipedia.org/wiki/Plain_Old_Java_Object>`_ classes
as MDS Entities. These will be treated in the same way as EUDE entities, instances of the DDEs will also be acessible through
the data browser. Users can still view the schema for these entities through the Schema Editor, add fields and modify
settings(although they can't remove fields declared in the entity class).

MEDE_ - MDS Enhanced Developer Defined Entity. These are DDEs that were enhanced with additional fields added either
through the UI or the Entity API. This are the same as DDE, but with additional fields added at runtime. Those fields
can be accessed at compile time using `Java Reflection API <https://docs.oracle.com/javase/tutorial/reflect/>`_.

Automatically added fields
##########################

All entities in MDS will be enhanced with the following fields automatically:

+------------------+-----------+--------------------------------------------------------------------------------------+
|Name              |Type       | Description                                                                          |
+==================+===========+======================================================================================+
|id                |Long       |The id field of the entity, used to uniquely identify the instance.                   |
+------------------+-----------+--------------------------------------------------------------------------------------+
|owner             |String     |The username of the owner of the instance. This field can be used with security       |
|                  |           |settings for the entity in order to filter access to only instance owners.            |
+------------------+-----------+--------------------------------------------------------------------------------------+
|creator           |String     |The username of the creator of the instance. Automatically set to username of the     |
|                  |           |Motech user that created the instance. Note that security can be set up to limit      |
|                  |           |instance access to only creators of those instances.                                  |
+------------------+-----------+--------------------------------------------------------------------------------------+
|modifiedBy        |String     |The username of the user that last modifier of the instance. Automatically set to the |
|                  |           |username of the user that last edited the entity. Updated automatically.              |
+------------------+-----------+--------------------------------------------------------------------------------------+
|creationDate      |DateTime   |The datetime on which this entity was created. Filled automatically.                  |
+------------------+-----------+--------------------------------------------------------------------------------------+
|modificationDate  |DateTime   |The datetime on which this entity was last modified. Updated automatically.           |
+------------------+-----------+--------------------------------------------------------------------------------------+

Access to these fields can be done through reflections, through re-declaring them in the DDE class or by inheriting
the **MDSEntity** class.

###########
MDS Lookups
###########

Lookups allow easily defining and executing queries on MDS entities. A lookup allows querying for a single or multiple
fields. A lookup field is always corresponding to a single field in the entity. It can be also configured to either return
a single or multiple results.

.. note::

    If more then one instance matches the criteria of a single return lookup, the lookup will fail.

Lookups at this moment can only use AND logic for doing a query for multiple fields. For OR(or move complex) logic
JDO queries have to be used TODO: link section. Lookup also allow comparing fields against provided parameters using a
custom operator or using a range or set of values, defining such lookups is not supported through the UI at the moment
though.


#############
Data Services
#############

All access to entities in MDS is done through Data Serviced. These are services implementing the
**org.motechproject.org.motechproject.mds.service.MotechDataService** interface. They are exposed as OSGi service that
can be retrieved from the OSGi BundleContext. All data access exposed by MDS, either ther REST API or the UI databrowser,
is done through these services. The class of the service is generated at runtime and it extends the base
**DefaultMotechDataService** class. :std:ref:`Developers can extend the **MotechDataService** interface <DDE_services>` in
order to add their own lookups to the interface.

.. TODO more info?

.. _EUDE:

################################
EUDE - End User Defined Entities
################################

These entities are created by end users, either through the UI or using the API. No programming knowledge is required
in order to define an EUDE. Although these entities are not known at compile time, unless the jar generated by MDS is added
to the classpath, programmatic access to these entities is still possible using
`Java Reflection API <https://docs.oracle.com/javase/tutorial/reflect/>`_ and some handy helper classes exposed by MDS.

.. note::

    All EUDE share the same java package: **org.motechproject.mds.entity**

.. _create_EUDE:

Creating EUDE through UI
########################

The easiest way to create EUDE entities is to use the Motech UI. First select **Data Services** from the left navigation
menu(**Modules** menu), then navigate to the **Schema Editor** tab. You will see a dropdown allowing to select an existing entity for
modification or deletion. Next to the dropdown menu you will see a New Entity button.

        .. image:: img/schema_editor.png
                :scale: 100 %
                :alt: MDS Schema Editor - adding new entity
                :align: center

After that the user is asked for the name of the entity. This can be anything that is a legal name of a class in Java.

        .. image:: img/entity_name.png
                :scale: 100 %
                :alt: MDS Schema Editor - enter entity name
                :align: center

The view for managing entity fields is then displayed to the user. Users can add a field by selecting its type, choosing a name
and a display name. 'display name' represents what will be visualised to the users in the MDS Data browser, task editor etc.
'name' represents the actual name of the field that will be used for class and table creation. After this data is entered,
hitting the green plus sign will add the field.

        .. image:: img/new_field.png
                :scale: 100 %
                :alt: MDS Schema Editor - adding a new field
                :align: center

The field is then expanded and the user is presented with options to modify the field settings:

The **Basic** sections allows to change the previously entered name and display name, it also allows marking the field
as required, meaning that users will be prevented from creating an instance without any value in this field. A default
value for the field can also be entered, as well as a tooltip that will be shown to users creating instances of the entity.

         .. image:: img/field_basic.png
                 :scale: 100 %
                 :alt: MDS Schema Editor - basic field settings
                 :align: center

The **Metadata** section allows adding metadata to the field. This used internally by MDS for features such as relationships.
End users should not worry about this section, but advanced can add any values they wish for their own processing needs.
Metadata is retrieved with the field schema using the Entity API. An example of using metadata could be a scenario when
we are writing a third party export tool, that takes the MDS Schema and imports it into a 3rd party system. The field
metadata can be used by that tool in order to recognize some fields as requiring special processing logic.

        .. image:: img/field_metadata.png
                :scale: 100 %
                :alt: MDS Schema Editor - metadata field settings
                :align: center

The **Validation** section allows setting specific validation rules for the field. Users will then be constrained by these
validations when creating instances of the entity. Validations are type specific.

        .. image:: img/field_validation.png
                :scale: 100 %
                :alt: MDS Schema Editor - field metadata
                :align: center

The **Settings** tab allows users to set type specific settings of the field. An example setting is the 'Max text length'
of a String field, which indicates the maximum length of the string at the database level.

        .. image:: img/field_settings.png
                :scale: 100 %
                :alt: MDS Schema Editor - field settings
                :align: center

Existing fields can be deleted using the trash bin icon next to their type.

        .. image:: img/field_delete.png
                :scale: 100 %
                :alt: MDS Schema Editor - delete field
                :align: center

When the user is done modifying the entity, clicking **Save changes** will save the changes to schema and regenerate
MDS entities. Clicking **Abandon Changes** will abandon all changes made by the user since the last save.

        .. image:: img/entity_save_abandon.png
                :scale: 100 %
                :alt: MDS Schema Editor - save or abandon changes
                :align: center

Defining a Lookup through the UI
################################

Users can use the UI for adding lookups to an entity. These lookup can then be executed either through the generated
services or using Data Browser UI. In order to add a new lookup, first open the advanced settings of an entity by
clicking the 'Advanced Settings' button.

MDS entities. Clicking **Abandon Changes** will abandon all changes made by the user since the last save.

        .. image:: img/entity_advanced.png
                :scale: 100 %
                :alt: MDS Schema Editor - advanced settings
                :align: center

After that users can create lookups by clicking on the 'New Lookup' button.

        .. image:: img/lookup_new.png
                :scale: 100 %
                :alt: MDS Schema Editor - adding a new lookup
                :align: center

The name fo the lookup can then be modified as well as whether it returns a single or multiple objects.
In order to make a lookup useful, it has be executed on a given set of fields, which can be added on the right side
of the window by clicking the 'New Lookup Field' button and selecting the right field from the dropdown. They can be
deleted using the trash bin button.

        .. image:: img/lookup_edit.png
                :scale: 100 %
                :alt: MDS Schema Editor - editing a lookup
                :align: center

In order to remove a lookup, the delete button in the lower right of dialog can be used.

        .. image:: img/lookup_delete.png
                :scale: 100 %
                :alt: MDS Schema Editor - deleting a lookup
                :align: center

Creating EUDE through the Entity API
####################################

Creation of entities can be also done using the **org.motechproject.mds.service.EntityService**.
This an OSGi service exposed by MDS which allows creation and modification of MDS entities, exposing everything
what the UI does.In order to use the service it has to be retrieved from the OSGi context, either directly using the
OSGi API to retrieve it from the BundleContext, or a Blueprint reference can be used to inject a proxy for that service
directly as a Spring bean.

Example of retrieving the service manually:

.. code-block:: java

    import org.motechproject.mds.service.EntityService;
    import org.osgi.framework.*;

    ...

    public EntityService getEntityService() {
        // note that if using Spring, the BundleContext can be injected as any other bean
        // which allows skipping this step
        BundleContext bundleContext = FrameworkUtil.getBundle(EntityService.class).getBundleContext();
        // get the service reference from the bundle context
        ServiceReference<EntityService> ref = bundleContext.getServiceReference(EntityService.class);
        // return the service for the reference, or null if there are no references
        // the service should always be available, so a null reference definitely indicates some sort error
        return ref == null ? null : bundleContext.getService(ref);
    }

and the preferred way using blueprint. Note that thanks to this declaration an EntityService bean becomes available
in your Spring context.

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:osgi="http://www.eclipse.org/gemini/blueprint/schema/blueprint"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.eclipse.org/gemini/blueprint/schema/blueprint
            http://www.eclipse.org/gemini/blueprint/schema/blueprint/gemini-blueprint.xsd">

        <osgi:reference id="entityService" interface="org.motechproject.mds.service.EntityService"/>

    </beans>


After getting hold of the service the entity can be created using the createEntity method:

.. code-block:: java

        EntityService entityService = getEntityService();


        EntityDto entity = new EntityDto("Patient");

        // the EntityDto instance returned will have the id value set
        entity = entityService.createEntity(entity);

.. _edit_EUDE_schema:

If we want to edit an existing entity, we can retrieve it using the EntityService:

.. code-block:: java

        // We can use the org.motechproject.mds.util.ClassName utility in order
        // to get the EUDE class name given just the name
        String className = ClassName.getEntityName("Patient");

        // className is org.motechproject.mds.entity.Patient

        EntityDto entity = entityService.getEntityByClassName(className);


When we have the EntityDto instance, fields can get added to the entity using the service and EntityDto returned:

.. code-block:: java

        // a simple integer field
        FieldDto simpleField = new FieldDto("simpleInt", "Simple integer", TypeDto.INTEGER);

        // a required name field
        FieldDto nameField = new FieldDto("name", "Patient Name", TypeDto.STRING, true);

        // an optional date of birth field, with a tooltip
        FieldDto dobField = new FieldDto("dob", "Date of Birth", TypeDto.DATETIME, false, null,
                "Patients date of birth, leave blank if unknown");

        // a required Social ID field, defaulting to 0
        FieldDto socialIdField = new FieldDto("socialId", "Social ID", TypeDto.LONG, true, 0L);

        // add the fields to the entity created earlier
        entityService.addFields(entity, simpleField, nameField, dobField, socialIdField);


In order to make these changes take effect, :std:ref:`data bundle regeneration must be triggered <Regeneration>`.

Creating Lookups through the API
################################

Just as any other edits on the entity schema, lookups can also be created using the EntityService.
In a similar fashion to fields, the **addLookups** method can be used for adding lookups to an entity.
Given the we have the EntityDto object and the EntityService(), we can create lookups in the following manner:

.. code-block:: java

        // this lookup will check the name field, during an exact comparison
        LookupDto lookupByName = new LookupDto("By name",
                true, // single object return
                true, // expose this lookup through REST
                Arrays.asList(new LookupFieldDto("name", LookupFieldDto.Type.VALUE)
        ));

        // this a complex lookup using multiple fields
        LookupDto complexLookup = new LookupDto("Complex lookup",
                false,  // return multiple objects
                false,  // do not expose by REST
            Arrays.asList(
                // the custom operator matches() will be used for querying on the name field
                new LookupFieldDto("name", LookupFieldDto.Type.VALUE, Constants.Operators.MATCHES),
                // the dob parameter will take a range, with a min and max value
                new LookupFieldDto("dob", LookupFieldDto.Type.RANGE),
                // for the state field, a set of possible values can be supplied
                new LookupFieldDto("state", LookupFieldDto.Type.SET))
        );

        // add the lookup
        entityService.addLookups(entity, lookupByName, complexLookup);

In order to make this changes take effect, :std:ref:`data bundle regeneration must be triggered <Regeneration>`.

.. _Regeneration:

Regenerating the entities bundle
################################

After we are done with modifications to the entity schema, we must trigger regeneration in order for the
classes to get updated and available in OSGi. For this we need to use org.motechproject.mds.service.JarGeneratorService,
which we can retrieve the same way that we can retrieve the EntityService. Once we have an instance of the service, all
we need to do is call the regenerateMdsDataBundle method:


.. code-block:: java

    JarGeneratorService jarGeneratorService = getJarGeneratorService();

    jarGeneratorService.regenerateMdsDataBundle();


After the schema gets regenerated and all bundles using MDS get refreshed, the EUDE class should be available for use.

Programmatic access to EUDE entities
####################################

EUDE classes can be accessed out of the bat using java reflections. This is an example of creating an instance
using reflections:

.. code-block:: java

    // first get the ClassName of the name entity
    // this helper method will always return org.motechproject.mds.entity.Patient
    String className = ClassName.getEntityName("Patient");

    // Retrieve the Data Service
    MotechDataService service = ServiceUtil.getServiceForEntityClassName(bundleContext, className);

    // Get the Class object for the entity
    Class entityClass = service.getClassType();

    // create a patient instance and set the name to "John"
    Object instance = entityClass.newInstance();
    PropertyUtil.setProperty(instance, "name", "John");

    // save it using the service
    service.create(instance);

As you can see the access is done through the Data Service. We can obtain the Class object for the
generated class and use it for doing all required operations.

.. TODO: do we have to import the class in OSGi?

Adding the generated jar to the classpath
#########################################

.. TODO: Make sure this works and describe how to do it
.. TODO: If it doesn't work we should drop this section for now & create a bug
.. TODO: Show how to do it with mvn and IntelliJ

.. _DDE:

################################
DDE - Developer Defined Entities
################################

Developers can use annotated `POJO <http://wikipedia.org/wiki/Plain_Old_Java_Object>`_ classes in order to define the
model for their application. Entities defined in this way will be treated in a similar fashion to EUDE_s, they can also
be accessed using the MDS data browser. New fields can also be added to DDEs - so that they become MEDE_.

DDEs are represented by actual Java classes used for defining them. OSGi bytecode weaving is used in order to enhance
these classes at runtime and to add additional fields for them. Because of this, these classes can be used with ease at
runtime, since they are available during compile time to developers using the module that defines them.

Defining entities - the @Entity annotation
##########################################

In order to define a DDE by using the **org.motechproject.mds.annotations.Entity** annotation. This are the contents of
Patient.java, an example fo a DDE entity:

.. code-block:: java

    package org.motechproject.example;

    import org.motechproject.mds.annotations.*;

    @Entity
    public class Patient {

    }

When the module containing this entity gets installed MDS will scan it for classes annotated with **@Entity**, and the
class above would get picked up by the processors. Schema for the entity is then generated and persisted in the schema
database of MDS, the class is also enhanced by DataNucleus. The MDS weaving hook then replaces the bytecode for this
class in module ClassLoaders, making it available to the modules using it.


DDE entity fields - @Field and @Ignore annotations
##################################################

An entity does not have much use without any fields. MDS will treat any public field in the class as an MDS field.
In the class below, the field **name** will be picked up automatically as field to be persisted in the database:

.. code-block:: java

    @Entity
    public class Patient {

        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }

The **@Field** annotation can be used for more explicit marking and control over the fields basic properties. In the
example below, the **required** parameter of the annotations is used to mark the name field as required, moreover the
physical column name in the database is set to "P_NAME":

.. code-block:: java

    @Entity
    public class Patient {

        @Field(name = "P_NAME", required = true)
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }

The @Field annotation could also be placed on the setter or getter methods for the same effect.

Not every public field, or not every field that has a public getter or setter has to be persisted in the database.
The **@Ignore** annotation can be used for marking such field as not persistent:

.. code-block:: java

    @Entity
    public class Patient {

        @Ignore
        public String name;
    }


The name field in the example above will not become a database field and no MDS schema will be generated for it. This
field will also not be accessible through the databrowser.


DDE relationships
#################

Using DataNucleus annotations
#############################

DataNucleus `JDO annotations <http://www.datanucleus.org/products/datanucleus/jdo/annotations.html>`_ can be used
for enhancing DDEs. These annotations will be taken into consideration by DataNucleus and override the metadata that
MDS generations. For example the **@javax.jdo.Unique** can be used in order to mark fields in an entity as unique.
Refer to the DataNucleus documentation for more information on using those annotations.

.. _DDE_services:

DDE service interfaces
######################

DDEs can define their own interfaces that extend the default service interface that will be used for generating
MDS services. The service will be published under that interface, and thanks to inheritance, it will also expose
type safe methods from the base service. HERE is example of defining an interface for a 'Patient' DDE:

.. code-block:: java

    public interface PatientDataService extends MotechDataService<Patient> {

    }

Thanks to this declaration type safe access to methods of the interface will be gained, the generic parameter Patient
will be inserted for the returned/parameter values.

This way of defining services for DDEs also allows to define additional lookups on the service. This lookups are defined
as plain method declarations with annotations. Their implementation will be generated at runtime by MDS. The lookup
method must be annotated with **@Lookup** annotation. Method parameters should be marked with @LookupField annotation
in order to connect the parameter with the actual entity field.

.. note::

    If the @LookupField annotation is not present, MDS ill fall back to trying to recognize the method parameter name,
    take note that this requires debug information at runtime, so you have to compile your classes with appropriately.

.. code-block:: java

    public interface PatientDataService extends MotechDataService<Patient> {

        /*
         * This lookup find a single patient based on the field 'name'.
         * So invoking this method like this: byName("John") will
         * return the patient with the name "John".
         */
        @Lookup
        Patient byName(@LookupField(name = "name") String name);

         /*
         * Same as above, but returns multiple results.
         */
        @Lookup
        List<Patient> byName2(@LookupField(name = "name") String name);
    }

The type of the parameter must match the type of the field, unless its one of the two special types:


**Range** - ranges can be used for looking up values that fall within the given range. An example is
a range of dates. Range consist of min and max values, you can provide only one of these values so there will be no
boundary on the second end.

.. code-block:: java

    public interface PatientDataService extends MotechDataService<Patient> {

        /*
         * Looks up patients for which their date of birth falls in the supplied range of
         * values. Example of usage:

            byDateOfBirth(new Range<>(DateTime.now().minusYears(30), DateTime.now().minusYears(10)));

         * this returns patients born between 30 and 10 years ago.
         */
        @Lookup
        List<Patient> byDateOfBirth(@LookupField(name = "dob") Range<DateTime> dobRange);

    }

**Set** - Doing lookups by sets is also possible. Instead of providing a single, you provide a set of values. If an
instance field matches one of the values, that is considered a hit.

.. code-block:: java

    public interface PatientDataService extends MotechDataService<Patient> {

        /*
         * Looks up patients which name matches one of the values from the set.
         * Usage example:
         *
         *  byName(new HashSet<>(Arrays.asList("Tom", "John", "Bob")));
         *
         * This will return patients named Tom, John or Bob.
         */
        @Lookup
        List<Patient> byName(@LookupField(name = "name") Set<String> names);

    }

Lookups can also use custom operators. The operator is inserted between the field name and the lookup parameter in
the JDO query generated. The default symbol is '=' - equality signed, however different operators can also be used.
Both JDO QL `operators <http://www.datanucleus.org/products/datanucleus/jdo/jdoql.html#operators>`_ and
`methods <http://www.datanucleus.org/products/datanucleus/jdo/jdoql.html#operators>`_ can be used for lookups.
If an operator like "<" is provided as the custom operator, it will be put between field name and parameter value.
If the operator has the form a function like "matches()" it will generate a method call of the form
"parameter.matches(value)" - the value is inserted between the brackets. In order to provide a custom operator for a
lookup field, the customOperator field of the @LookupField annotation has to be set:

.. code-block:: java

    public interface PatientDataService extends MotechDataService<Patient> {

        /*
         * Does a matches() lookup on the name field.
         * Because matches() is used, a regex pattern can be passed as the parameter.
         */
        @Lookup
        List<Patient> byName(@LookupField(name = "name", customOperator = "matches()") String name);

    }

.. note::

    The list of standard JDO operators that can be used in lookups are defined as constants in the
    class **org.motechproject.mds.util.Constants.Operators**.

Programmatic usage of DDE entities
##################################

All that has to be done in order to use a DDE is to retrieve the service for the its interface. Because of the nature
of DDEs, their classes are available during compile time. The service reference can be either retrieved using the
standard OSGi facilities:

.. code-block:: java

    public PatientService getPatientService() {
        BundleContext bundleContext = FrameworkUtil.getBundle(Patient.class).getBundleContext();
        ServiceReference<PatientService> ref = bundleContext.getServiceReference(PatientService.class);
        return ref == null ? null : bundleContext.getService(ref);
    }

The preferred way however is to use Blueprint OSGi references. The service will be injected as a Spring bean into the
Spring application context of the module and can be then used as any other bean(for example it can be @Autowired into
other beans).

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:osgi="http://www.eclipse.org/gemini/blueprint/schema/blueprint"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.eclipse.org/gemini/blueprint/schema/blueprint
            http://www.eclipse.org/gemini/blueprint/schema/blueprint/gemini-blueprint.xsd">

        <osgi:reference id="patientDataService" interface="org.motechproject.example.PatientService"/>

    </beans>

Once the service instance is obtained, its method can be simply used in order to do CRUD operations on the entity.

.. note::

    Usually a module should provide a service layer between the end user and the data layer implemented by MDS.
    Its not required however and left to the implementer.

.. _MEDE:

##############################################
MEDE - MDS Enhanced Developer Defined Entities
##############################################

MEDE, MDS Enhanced Developer Defined Entities, are the DDE_ that were enhanced by users with additional fields at
runtime. In practice they are not different from DDEs in way. The only difference lies in the additional fields.
These fields are not part of the class at compile time, so access to these fields has to be done using reflections.
They can also be set through the MDS data browser, so this a way for nontechnical users to attach their own values to
the model.

Extending DDEs through the UI
#############################

Extending DDEs through the UI is not different from manipulating the schema of EUDE entities. Refer to the documentation
section on :std:ref:`creating EUDE entities <create_EUDE>` for more info. In order to extend a DDE first go the MDS
Schema Editor and select the DDE entity you wish to edit:

        .. image:: img/select_dde.png
                :scale: 100 %
                :alt: MEDE - select DDE
                :align: center

Next add the field you wish to add to the entity:

        .. image:: img/dde_new_field.png
                :scale: 100 %
                :alt: MEDE - add new field to DDE
                :align: center

You can also add lookup to the DDE:

        .. image:: img/dde_new_lookup.png
                :scale: 100 %
                :alt: MEDE - add new lookup to DDE
                :align: center

Finally, save your changes to trigger MDS schema regeneration and make your changes take effect(you can also abandon
your changes if you wish):

        .. image:: img/save_mede.png
                :scale: 100 %
                :alt: MEDE - save MEDE
                :align: center

Extending DDEs through code
###########################

Extending DDEs through code is no different from extending EUDE entities. The only difference is that the EntityDto for
the DDE has to be retrieved by providing its class name. Refer to the documentation on
:std:ref:`extending EUDE through code <edit_EUDE_schema>`.


#####################
Supported field types
#####################


#############################
History tracking for entities
#############################
MDS allows to keep track of any changes made on the instances, as well as reverting the state of an instance to a
concrete revision. Both viewing the history of an instance and reverting can be done via the code and UI. This feature
will only be available if you explicitly set, that the history tracking for your entity should be enabled. If you want to
view the history for your instance via UI, simply go to the detailed view of that instance, and click on the **History** button.

            .. image:: img/instance_history.png
                    :scale: 100 %
                    :alt: Detailed view of an instance - history
                    :align: center

.. note::

    If you introduce any changes to the entity definition (e.g. add or delete a field), you will still be able to view
    the state of an instance, but you will lose the ability to revert an instance (because of a schema mismatch).

Controlling whether to record history
#####################################
By default MDS doesn't keep track of the instance revisions. Most of the DDEs that come with MOTECH modules have the
tracking of the history disabled as well. To enable history tracking for the...

- Developer Defined Entity (DDE) - You have to set the **recordHistory** parameter of the **@Entity** annotation to true.

.. code-block:: java

    @Entity(recordHistory = true)

- End User Defined Entity (EUDE) - The **Enable history recording** option is available under the **Advanced** window of
  an entity, in the **Auditing & Revision Tracking** tab

            .. image:: img/entity_history_tracking.png
                    :scale: 100 %
                    :alt: MDS Schema Editor - History Tracking setting
                    :align: center


Retrieving history using code
#############################
MDS exposes an implementation of the **org.motechproject.mds.service.HistoryService**. To make use of it, you should simply
create a reference to that service in your blueprint:

.. code-block:: xml

    <osgi:reference id="historyServiceOSGi" interface="org.motechproject.mds.service.HistoryService" />

From now on, you will be able to use the history service, just like any other Spring bean, for example, by placing the
**@Autowired** annotation on a field of type **org.motechproject.mds.service.HistoryService**. The service allows recording
history, deleting the whole history for an instance and retrieving the historical revisions of an instance.


#############
MDS Trash Bin
#############
When an instance is deleted, it can either be removed completely or moved to the trash. In case an instance is moved
to the trash, there will be an ability to view all instances that have been deleted, as well as to restore any instance
from the trash. Users may also choose to empty the trash from time to time. All the data retention settings are available
in the MDS settings tab. If you choose to empty the trash, MDS will use the scheduler to set up a job, that runs every
specified period and empties the trash.

            .. image:: img/mds_settings.png
                    :scale: 100 %
                    :alt: MDS Settings panel
                    :align: center

To view instances that have been moved to the trash, click the **View trash** button, after selecting an entity in the
data browser. To restore any instance from the trash, select that instance and click **Restore** button on the detailed
view of the deleted instance.

            .. image:: img/data_browser_view_trash.png
                    :scale: 100 %
                    :alt: MDS Data browser - view trash
                    :align: center

.. note::

    If you introduce any changes to the entity definition (e.g. add or delete a field), you will lose access to all
    the deleted instances of the previous schema. That means you will no longer be able to view or restore them anymore.


Using Trash using code
######################
Similar to the HistoryService mentioned above, MDS also exposes the **TrashService** that allows operations on the
Trash bin from the code. To use the exposed service, create a reference in your blueprint file:

.. code-block:: xml

    <osgi:reference id="trashServiceOSGi" interface="org.motechproject.mds.service.TrashService" />

Accessing the service also works the same way as with the HistoryService - treat it as any other Spring bean, for example
by placing the **@Autowired** annotation on the field of type **org.motechproject.mds.service.TrashService**. The trash
service allows to place instances in trash, retrieve instances from trash, schedule the trash purging, empty the trash
and check current data retention settings.


####################
The MDS data browser
####################
Seba~


######################
Data browsing settings
######################
Seba~

Changing the settings through the UI
####################################
Seba~

Changing the settings through annotations
#########################################
Seba~

############
The REST API
############


REST endpoints
##############

REST fields exposed
###################

Changing REST settings through the UI
#####################################

Changing REST settings through annotations
##########################################


##################
Entity validations
##################

Configuring validations through the UI
######################################

Configuring validations using annotations
#########################################

##################
MDS Lookup Service
##################


########################
Executing custom queries
########################

########
Security
########
Seba~

#################
Tasks integration
#################

#######
Javadoc
#######

:doc:`/org/motechproject/mds/service/package-index`

:doc:`/org/motechproject/mds/annotations/package-index`

:doc:`/org/motechproject/mds/builder/package-index`

:doc:`/org/motechproject/mds/config/package-index`

:doc:`/org/motechproject/mds/domain/package-index`

:doc:`/org/motechproject/mds/dto/package-index`

:doc:`/org/motechproject/mds/enhancer/package-index`

:doc:`/org/motechproject/mds/ex/package-index`

:doc:`/org/motechproject/mds/filter/package-index`

:doc:`/org/motechproject/mds/jdo/package-index`

:doc:`/org/motechproject/mds/repository/package-index`

:doc:`/org/motechproject/mds/util/package-index`

:doc:`/org/motechproject/mds/web/package-index`
